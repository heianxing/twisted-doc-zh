<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>编写服务器</title>
  </head>

  <body>
    <h1>编写服务器</h1>

    <h2>概述</h2>

    <p>Twisted是一个非常灵活的框架，能让你编写出强大的服务器。而灵活的代价，就是编写服务器需要用的几个层。</p>

    <p>这篇文档描述了协议（<code class="API" base="twisted.internet.protocol">Protocol</code>）层，我们的程序要在这里依照既定协议对数据进行分析和处理。如果你在写一个应用程序，那么在读这篇文档之前，你应该先在<a href="plugin.xhtml">《编写Twisted插件》</a>里，读一下关于如何开始编写Twisted应用程序的顶层概述。这篇文档只讨论TCP、SSL与Unix套接字服务器，有<a href="udp.xhtml">另外一篇文档</a>讨论UDP。</p>

    <p>你的协议处理类通常会继承<code class="API">twisted.internet.protocol.Protocol</code>。大多数协议处理程序要么继承自这个类，要么继承自它更便捷的子类。协议类实例通常在连接建立时根据需要实例化产生，连接断开后消失。这意味着持久的配置不能保存在<code>Protocol</code>里。</p>

    <p>持久的配置由一个工厂类来保管，这个工厂类通常继承自<code class="API">twisted.internet.protocol.Factory</code>。默认的工厂类仅仅实例化每个<code>Protocol</code>，然后给每个实例设置一个指向工厂自己<code>factory</code>属性。这样每个<code>Protocol</code>都可以访问持久的配置，并且修改他们。</p>

    <p>在多个端口或是不同网络地址上提供一样的服务通常是很有用处的。这就是为什么<code>Factory</code>不监听连接，并且实际上对网络一无所知。更多信息见<code class="API">twisted.internet.interfaces.IReactorTCP.listenTCP</code>，以及其他的<code>IReactor*.listen*</code>API。</p>

    <p>这篇文档将一步一步地说明。</p>

    <h2>协议</h2>

    <p>正如之前提到的，协议与一些辅助的类和函数，包含了大部分的代码。Twisted的协议程序以异步的方式来处理数据，这就是说，协议程序从来不会等待一个事件，当网络上来了一个事件时，协议程序会作出响应。</p>

    <p>这里有一个简单的例子：</p>
<pre class="python">
from twisted.internet.protocol import Protocol

class Echo(Protocol):

    def dataReceived(self, data):
        self.transport.write(data)
</pre>

    <p>This is one of the simplest protocols. It simply writes back
    whatever is written to it, and does not respond to all events. Here is an
    example of a Protocol responding to another event:</p>
<pre class="python">
from twisted.internet.protocol import Protocol

class QOTD(Protocol):

    def connectionMade(self):
        self.transport.write("An apple a day keeps the doctor away\r\n") 
        self.transport.loseConnection()
</pre>

    <p>This protocol responds to the initial connection with a well
    known quote, and then terminates the connection.</p>

    <p>The connectionMade event is usually where set up of the
    connection object happens, as well as any initial greetings (as
    in the QOTD protocol above, which is actually based on RFC
    865). The <code>connectionLost</code> event is where tearing down of any
    connection-specific objects is done. Here is an example:</p>
<pre class="python">
from twisted.internet.protocol import Protocol

class Echo(Protocol):

    def connectionMade(self):
        self.factory.numProtocols = self.factory.numProtocols+1 
        if self.factory.numProtocols &gt; 100:
            self.transport.write("Too many connections, try later") 
            self.transport.loseConnection()

    def connectionLost(self, reason):
        self.factory.numProtocols = self.factory.numProtocols-1

    def dataReceived(self, data):
        self.transport.write(data)
</pre>

    <p>Here <code>connectionMade</code> and
    <code>connectionLost</code> cooperate to keep a count of the
    active protocols in the factory. <code>connectionMade</code>
    immediately closes the connection if there are too many active
    protocols.</p>

    <h3>Using the Protocol</h3>

    <p>In this section, I will explain how to test your protocol
    easily. (In order to see how you should write a production-grade Twisted
    server, though, you should read the <a href="plugin.xhtml" >Writing Plug-Ins
    for Twisted</a> HOWTO as well).</p>

    <p>Here is code that will run the QOTD server discussed
    earlier</p>
<pre class="python">
from twisted.internet.protocol import Protocol, Factory
from twisted.internet import reactor

class QOTD(Protocol):

    def connectionMade(self):
        self.transport.write("An apple a day keeps the doctor away\r\n") 
        self.transport.loseConnection()

# Next lines are magic:
factory = Factory()
factory.protocol = QOTD

# 8007 is the port you want to run under. Choose something &gt;1024
reactor.listenTCP(8007, factory)
reactor.run()
</pre>

    <p>Don't worry about the last 6 magic lines -- you will
    understand what they do later in the document.</p>

    <h3>Helper Protocols</h3>

    <p>Many protocols build upon similar lower-level abstraction.
    The most popular in internet protocols is being line-based.
    Lines are usually terminated with a CR-LF combinations.</p>

    <p>However, quite a few protocols are mixed - they have
    line-based sections and then raw data sections. Examples
    include HTTP/1.1 and the Freenet protocol.</p>

    <p>For those cases, there is the <code>LineReceiver</code>
    protocol. This protocol dispatches to two different event
    handlers - <code>lineReceived</code> and
    <code>rawDataReceived</code>. By default, only
    <code>lineReceived</code> will be called, once for each line.
    However, if <code>setRawMode</code> is called, the protocol
    will call <code>rawDataReceived</code> until
    <code>setLineMode</code> is called, which returns it to using
    <code>lineReceived</code>.</p>

    <p>Here is an example for a simple use of the line
    receiver:</p>
<pre class="python">
from twisted.protocols.basic import LineReceiver

class Answer(LineReceiver):

    answers = {'How are you?': 'Fine', None : "I don't know what you mean"}

    def lineReceived(self, line):
        if self.answers.has_key(line):
            self.sendLine(self.answers[line])
        else:
            self.sendLine(self.answers[None])
</pre>

    <p>Note that the delimiter is not part of the line.</p>

    <p>Several other, less popular, helpers exist, such as a
    netstring based protocol and a prefixed-message-length
    protocol.</p>

    <h3>State Machines</h3>

    <p>Many Twisted protocol handlers need to write a state machine
    to record the state they are at. Here are some pieces of advice
    which help to write state machines:</p>

    <ul>
      <li>Don't write big state machines. Prefer to write a state
      machine which deals with one level of abstraction at a
      time.</li>

      <li>Use Python's dynamicity to create open ended state
      machines. See, for example, the code for the SMTP
      client.</li>

      <li>Don't mix application-specific code with Protocol
      handling code. When the protocol handler has to make an
      application-specific call, keep it as a method call.</li>
    </ul>

    <h2>Factories</h2>

    <p>As mentioned before, usually the class <code
    class="API">twisted.internet.protocol.Factory</code> works,
    and there is no need to subclass it. However, sometimes there
    can be factory-specific configuration of the protocols, or
    other considerations. In those cases, there is a need to
    subclass <code>Factory</code>.</p>

    <p>For a factory which simply instantiates instances of a
    specific protocol class, simply instantiate
    <code>Factory</code>, and sets its <code>protocol</code> attribute:</p>
<pre class="python">
from twisted.internet.protocol import Factory
from twisted.protocols.wire import Echo

myFactory = Factory()
myFactory.protocol = Echo
</pre>

    <p>If there is a need to easily construct factories for a
    specific configuration, a factory function is often useful:</p>
<pre class="python">
from twisted.internet.protocol import Factory, Protocol

class QOTD(Protocol):

    def connectionMade(self):
        self.transport.write(self.factory.quote+'\r\n')
        self.transport.loseConnection()


def makeQOTDFactory(quote=None):
    factory = Factory()
    factory.protocol = QOTD
    factory.quote = quote or 'An apple a day keeps the doctor away'
    return factory
</pre>

    <p>A Factory has two methods to perform application-specific
    building up and tearing down (since a Factory is frequently
    persisted, it is often not appropriate to do them in <code>__init__</code>
    or <code>__del__</code>, and would frequently be too early or too late).</p>

    <p>Here is an example of a factory which allows its Protocols
    to write to a special log-file:</p>
<pre class="python">
from twisted.internet.protocol import Factory
from twisted.protocols.basic import LineReceiver


class LoggingProtocol(LineReceiver):

    def lineReceived(self, line):
        self.factory.fp.write(line+'\n')


class LogfileFactory(Factory):

    protocol = LoggingProtocol

    def __init__(self, fileName):
        self.file = fileName

    def startFactory(self):
        self.fp = open(self.file, 'a')

    def stopFactory(self):
        self.fp.close()
</pre>

    <h3>Putting it All Together</h3>

    <p>So, you know what factories are, and want to run the QOTD
    with configurable quote server, do you? No problems, here is an
    example.</p>

<pre class="python">
from twisted.internet.protocol import Factory, Protocol
from twisted.internet import reactor

class QOTD(Protocol):

    def connectionMade(self):
        self.transport.write(self.factory.quote+'\r\n')
        self.transport.loseConnection()


class QOTDFactory(Factory):

    protocol = QOTD

    def __init__(self, quote=None):
        self.quote = quote or 'An apple a day keeps the doctor away'

reactor.listenTCP(8007, QOTDFactory("configurable quote"))
reactor.run()
</pre>

    <p>The only lines you might not understand are the last two.</p>

<p><code class="API"
base="twisted.internet.interfaces.IReactorTCP">listenTCP</code> is
the method which connects a <code>Factory</code> to the network.
It uses the reactor interface, which lets many different loops handle
the networking code, without modifying end-user code, like this.
As mentioned above, if you want to write your code to be a production-grade
Twisted server, and not a mere 20-line hack, you will want to
use <a href="application.xhtml">the Application object</a>.</p>

  </body>
</html>
