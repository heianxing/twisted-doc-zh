<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>编写服务器</title>
  </head>

  <body>
    <h1>编写服务器</h1>

    <h2>概述</h2>

    <p>Twisted是一个非常灵活的框架，能让你编写出强大的服务器。而灵活的代价就是编写服务器时，需要分好几层。</p>

    <p>这篇文档描述了协议（<code class="API" base="twisted.internet.protocol">Protocol</code>）层，我们的程序要在这里依照既定协议对数据进行分析和处理。如果你在写一个应用程序，那么在读这篇文档之前，你应该先在<a href="plugin.xhtml">《编写Twisted插件》</a>里，读一下关于如何开始编写Twisted应用程序的总体概述。这篇文档只讨论TCP、SSL与Unix套接字服务器，有<a href="udp.xhtml">另外一篇文档</a>讨论UDP。</p>

    <p>你的协议处理类通常是<code class="API">twisted.internet.protocol.Protocol</code>的子类。大多数协议处理程序要么继承自这个类，要么继承自它的某个更便捷的子类。系统会根据需要，为每个连接创建一个协议类的实例，连接断开后就不用了。这就意味着<code>Protocol</code>里没存持久配置（比如服务器端口等——译者注）。</p>

    <p>持久配置由一个工厂类来保管，这个工厂类通常继承自<code class="API">twisted.internet.protocol.Factory</code>。默认的工厂类仅仅把<code>Protocol</code>实例化，并且给每个实例设置一个指向工厂自己的属性<code>factory</code>。这样每个<code>Protocol</code>都可以访问持久配置，并且可以修改他们。</p>

    <p>在多个端口或是不同网络地址上提供一样的服务通常是很有用处的。这就是为什么<code>Factory</code>不监听连接，并且实际上对网络一无所知。更多信息见<code class="API">twisted.internet.interfaces.IReactorTCP.listenTCP</code>，以及其他的<code>IReactor*.listen*</code>API。</p>

    <p>这篇文档会解释上面的每一步。</p>

    <h2>协议</h2>

    <p>正如之前提到的，大部分的代码都在协议与一些辅助的类和函数中。Twisted的协议程序以异步的方式来处理数据，这就是说，协议程序从来不会去等待一个事件，而是当网络上的事件到达时再去响应。</p>

    <p>这里有一个简单的例子：</p>
<pre class="python">
from twisted.internet.protocol import Protocol

class Echo(Protocol):

    def dataReceived(self, data):
        self.transport.write(data)
</pre>

    <p>这是一个最简单的协议，它只是把收到的内容写回去，并没有响应所有的事件。下面这个例子中响应了另一个事件：</p>
<pre class="python">
from twisted.internet.protocol import Protocol

class QOTD(Protocol):

    def connectionMade(self):
        self.transport.write("一天一苹果，医生不缠我\r\n") 
        self.transport.loseConnection()
</pre>

    <p>这个协议在建立连接之后，发送一条谚语（原文是“An apple a day keeps the doctor away”——译者注），然后断开连接。</p>

	<p><code>connectionMade</code>事件通常发生在连接对象构建的时候，以及任何初始化握手时（像上面的QOTD协议，其实它是根据RFC 865写的（RFC 865就是Quote of the Day Protocol——译者注））。<code>connectionLost</code>事件发生在连接特定的各种对象销毁时。
    in the QOTD protocol above, which is actually based on RFC
    865). The <code>connectionLost</code> event is where tearing down of any
    connection-specific objects is done. Here is an example:</p>
<pre class="python">
from twisted.internet.protocol import Protocol

class Echo(Protocol):

    def connectionMade(self):
        self.factory.numProtocols = self.factory.numProtocols+1 
        if self.factory.numProtocols &gt; 100:
            self.transport.write("Too many connections, try later") 
            self.transport.loseConnection()

    def connectionLost(self, reason):
        self.factory.numProtocols = self.factory.numProtocols-1

    def dataReceived(self, data):
        self.transport.write(data)
</pre>

    <p>Here <code>connectionMade</code> and
    <code>connectionLost</code> cooperate to keep a count of the
    active protocols in the factory. <code>connectionMade</code>
    immediately closes the connection if there are too many active
    protocols.</p>

    <h3>Using the Protocol</h3>

    <p>In this section, I will explain how to test your protocol
    easily. (In order to see how you should write a production-grade Twisted
    server, though, you should read the <a href="plugin.xhtml" >Writing Plug-Ins
    for Twisted</a> HOWTO as well).</p>

    <p>Here is code that will run the QOTD server discussed
    earlier</p>
<pre class="python">
from twisted.internet.protocol import Protocol, Factory
from twisted.internet import reactor

class QOTD(Protocol):

    def connectionMade(self):
        self.transport.write("An apple a day keeps the doctor away\r\n") 
        self.transport.loseConnection()

# Next lines are magic:
factory = Factory()
factory.protocol = QOTD

# 8007 is the port you want to run under. Choose something &gt;1024
reactor.listenTCP(8007, factory)
reactor.run()
</pre>

    <p>Don't worry about the last 6 magic lines -- you will
    understand what they do later in the document.</p>

    <h3>Helper Protocols</h3>

    <p>Many protocols build upon similar lower-level abstraction.
    The most popular in internet protocols is being line-based.
    Lines are usually terminated with a CR-LF combinations.</p>

    <p>However, quite a few protocols are mixed - they have
    line-based sections and then raw data sections. Examples
    include HTTP/1.1 and the Freenet protocol.</p>

    <p>For those cases, there is the <code>LineReceiver</code>
    protocol. This protocol dispatches to two different event
    handlers - <code>lineReceived</code> and
    <code>rawDataReceived</code>. By default, only
    <code>lineReceived</code> will be called, once for each line.
    However, if <code>setRawMode</code> is called, the protocol
    will call <code>rawDataReceived</code> until
    <code>setLineMode</code> is called, which returns it to using
    <code>lineReceived</code>.</p>

    <p>Here is an example for a simple use of the line
    receiver:</p>
<pre class="python">
from twisted.protocols.basic import LineReceiver

class Answer(LineReceiver):

    answers = {'How are you?': 'Fine', None : "I don't know what you mean"}

    def lineReceived(self, line):
        if self.answers.has_key(line):
            self.sendLine(self.answers[line])
        else:
            self.sendLine(self.answers[None])
</pre>

    <p>Note that the delimiter is not part of the line.</p>

    <p>Several other, less popular, helpers exist, such as a
    netstring based protocol and a prefixed-message-length
    protocol.</p>

    <h3>State Machines</h3>

    <p>Many Twisted protocol handlers need to write a state machine
    to record the state they are at. Here are some pieces of advice
    which help to write state machines:</p>

    <ul>
      <li>Don't write big state machines. Prefer to write a state
      machine which deals with one level of abstraction at a
      time.</li>

      <li>Use Python's dynamicity to create open ended state
      machines. See, for example, the code for the SMTP
      client.</li>

      <li>Don't mix application-specific code with Protocol
      handling code. When the protocol handler has to make an
      application-specific call, keep it as a method call.</li>
    </ul>

    <h2>Factories</h2>

    <p>As mentioned before, usually the class <code
    class="API">twisted.internet.protocol.Factory</code> works,
    and there is no need to subclass it. However, sometimes there
    can be factory-specific configuration of the protocols, or
    other considerations. In those cases, there is a need to
    subclass <code>Factory</code>.</p>

    <p>For a factory which simply instantiates instances of a
    specific protocol class, simply instantiate
    <code>Factory</code>, and sets its <code>protocol</code> attribute:</p>
<pre class="python">
from twisted.internet.protocol import Factory
from twisted.protocols.wire import Echo

myFactory = Factory()
myFactory.protocol = Echo
</pre>

    <p>If there is a need to easily construct factories for a
    specific configuration, a factory function is often useful:</p>
<pre class="python">
from twisted.internet.protocol import Factory, Protocol

class QOTD(Protocol):

    def connectionMade(self):
        self.transport.write(self.factory.quote+'\r\n')
        self.transport.loseConnection()


def makeQOTDFactory(quote=None):
    factory = Factory()
    factory.protocol = QOTD
    factory.quote = quote or 'An apple a day keeps the doctor away'
    return factory
</pre>

    <p>A Factory has two methods to perform application-specific
    building up and tearing down (since a Factory is frequently
    persisted, it is often not appropriate to do them in <code>__init__</code>
    or <code>__del__</code>, and would frequently be too early or too late).</p>

    <p>Here is an example of a factory which allows its Protocols
    to write to a special log-file:</p>
<pre class="python">
from twisted.internet.protocol import Factory
from twisted.protocols.basic import LineReceiver


class LoggingProtocol(LineReceiver):

    def lineReceived(self, line):
        self.factory.fp.write(line+'\n')


class LogfileFactory(Factory):

    protocol = LoggingProtocol

    def __init__(self, fileName):
        self.file = fileName

    def startFactory(self):
        self.fp = open(self.file, 'a')

    def stopFactory(self):
        self.fp.close()
</pre>

    <h3>Putting it All Together</h3>

    <p>So, you know what factories are, and want to run the QOTD
    with configurable quote server, do you? No problems, here is an
    example.</p>

<pre class="python">
from twisted.internet.protocol import Factory, Protocol
from twisted.internet import reactor

class QOTD(Protocol):

    def connectionMade(self):
        self.transport.write(self.factory.quote+'\r\n')
        self.transport.loseConnection()


class QOTDFactory(Factory):

    protocol = QOTD

    def __init__(self, quote=None):
        self.quote = quote or 'An apple a day keeps the doctor away'

reactor.listenTCP(8007, QOTDFactory("configurable quote"))
reactor.run()
</pre>

    <p>The only lines you might not understand are the last two.</p>

<p><code class="API"
base="twisted.internet.interfaces.IReactorTCP">listenTCP</code> is
the method which connects a <code>Factory</code> to the network.
It uses the reactor interface, which lets many different loops handle
the networking code, without modifying end-user code, like this.
As mentioned above, if you want to write your code to be a production-grade
Twisted server, and not a mere 20-line hack, you will want to
use <a href="application.xhtml">the Application object</a>.</p>

  </body>
</html>
